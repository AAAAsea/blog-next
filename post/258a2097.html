<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="https://blog.asea.fun/img/avatar1.png"><link rel="icon" type="image/png" sizes="16x16" href="https://blog.asea.fun/img/avatar1.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-big-counter.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"asea.fun",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"default"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!0,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!1,nav:null,activeClass:"valine"},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="四大件 数据结构和算法 计算机网络 操作系统 设计模式组成原理  数据类型 常量 ​    宏常量 #define ​    const 修饰变量 ​    均不可修改  字符串 char str[] &#x3D; “ldksjfa”，会默认多一个’\0’ string str &#x3D; “dlkjafd” 需要头文件  bool char int float double void wchar_t  typed"><meta property="og:type" content="article"><meta property="og:title" content="c++学习笔记"><meta property="og:url" content="https://asea.fun/post/258a2097.html"><meta property="og:site_name" content="AseaBlog"><meta property="og:description" content="四大件 数据结构和算法 计算机网络 操作系统 设计模式组成原理  数据类型 常量 ​    宏常量 #define ​    const 修饰变量 ​    均不可修改  字符串 char str[] &#x3D; “ldksjfa”，会默认多一个’\0’ string str &#x3D; “dlkjafd” 需要头文件  bool char int float double void wchar_t  typed"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://pic.imgdb.cn/item/6112334a5132923bf840aea3.jpg"><meta property="og:image" content="https://pic.imgdb.cn/item/612e56ce44eaada73961cd6b.jpg"><meta property="og:image" content="https://pic.imgdb.cn/item/613d583444eaada739877124.jpg"><meta property="og:image" content="https://pic.imgdb.cn/item/613d58b044eaada739880e76.jpg"><meta property="og:image" content="https://pic.imgdb.cn/item/613d5daa44eaada7398e970d.jpg"><meta property="article:published_time" content="2021-07-25T15:40:14.000Z"><meta property="article:modified_time" content="2021-09-12T03:03:00.000Z"><meta property="article:author" content="Asea"><meta property="article:tag" content="c++"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://pic.imgdb.cn/item/6112334a5132923bf840aea3.jpg"><link rel="canonical" href="https://asea.fun/post/258a2097.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>c++学习笔记 | AseaBlog</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="AseaBlog" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta custom-logo"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">AseaBlog</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">我的个人博客</p> <a><img class="custom-logo-image" src="/uploads/logo2.png" alt="AseaBlog"></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-主页"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 主页</a></li><li class="menu-item menu-item-关于"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i> 关于</a></li><li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签</a></li><li class="menu-item menu-item-分类"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类</a></li><li class="menu-item menu-item-留言"><a href="/liuyan/" rel="section"><i class="fa fa-comments fa-fw"></i> 留言</a></li><li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a> <a href="https://github.com/AAAAsea" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://asea.fun/post/258a2097.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar1.png"><meta itemprop="name" content="Asea"><meta itemprop="description" content="我以為我可以獨自過一生 我還是被打動了"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AseaBlog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> c++学习笔记</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-07-25 23:40:14" itemprop="dateCreated datePublished" datetime="2021-07-25T23:40:14+08:00">2021-07-25</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-09-12 11:03:00" itemprop="dateModified" datetime="2021-09-12T11:03:00+08:00">2021-09-12</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a></span></span><span class="post-meta-item" title="热度" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">热度：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/post/258a2097.html#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/post/258a2097.html" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="四大件"><a href="#四大件" class="headerlink" title="四大件"></a>四大件</h2><ol><li>数据结构和算法</li><li>计算机网络</li><li>操作系统</li><li>设计模式组成原理</li></ol><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol><li><p>常量</p><p>​ 宏常量 #define</p><p>​ const 修饰变量</p><p>​ 均不可修改</p></li><li><p>字符串</p><p>char str[] = “ldksjfa”，会默认多一个’\0’</p><p>string str = “dlkjafd” 需要头文件<string></string></p></li><li><p>bool char int float double void wchar_t</p></li><li><p>typedef为已有类命新名字</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> feet;</span><br><span class="line">feet a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ol><li>三目运算符可以返回变量也可以返回变量值</li></ol><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><ol><li>if - else if - else</li><li>switch - case break- case break-default break <strong>只能是int 或者 char，必须break</strong></li><li>循环结构 while（）{},do{}while()，for(int i =0;i&lt;10;i++)</li><li>goto FLAG; FLAG:</li><li>continue</li></ol><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><ol><li><p>定义数组</p><ol><li>int a[10];</li><li>int a[10] = {0,1,2,3,4,5,6,7,8,9}</li><li>int a[] = {0,1,2,3}</li></ol></li><li><p>特点</p><ol><li>数据类型相同</li><li>内存空间连续</li></ol></li><li><p>赋值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//初始化表长度小于要被初始化的数组的元素数目，剩余元素均为0；</span></span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p><strong>注意</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span> a[n]; <span class="comment">//这是错误的写法，尽管有些编译器可能不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b[<span class="number">0</span>]; <span class="comment">//长度为0的数组没有任何意义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;c[<span class="number">11</span>]; <span class="comment">//越界但可以输出</span></span><br></pre></td></tr></table></figure></li><li><p>排序查找</p><p>选择排序</p><p>冒泡排序</p></li></ol><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><ol><li><p>初始化赋值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>][<span class="number">10</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> a[][<span class="number">10</span>] = &#123;&#123;&#125;,&#123;&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><strong>注意</strong><ol><li>行数</li><li>元素数目（用好sizeof())</li><li>理解好变量名与地址的关系</li></ol></li></ol><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ol><li><p>初始化</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[] = &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> ch[] = &#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> ch[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> ch[] = <span class="string">&quot;hello&quot;</span>; <span class="comment">//这是错误的</span></span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">10</span>] = <span class="string">&quot;hello&quot;</span>; <span class="comment">//后面的字符都是&#x27;\0&#x27;,&#x27;\0&#x27;是不可显示的</span></span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">6</span>] = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125; <span class="comment">//是字符串</span></span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">5</span>] = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125; <span class="comment">//不是字符串</span></span><br></pre></td></tr></table></figure></li><li><p>空字符串</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[] = <span class="string">&quot;&quot;</span>; <span class="comment">//占用一个字节存储&#x27;\0&#x27;</span></span><br><span class="line"><span class="comment">//&#x27;a&#x27;与&quot;a&quot;，前者是简单的变量，后者是数组</span></span><br></pre></td></tr></table></figure></li><li><p>遍历</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>（<span class="keyword">int</span> i = <span class="number">0</span>; str[i]!=<span class="string">&#x27;\0&#x27;</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输入输出</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">6</span>];</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;str; <span class="comment">//空格字符会结束输入</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str; <span class="comment">//遇到第一个&#x27;\0&#x27;结束。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>.get(str, length, endchar); <span class="comment">//结束字符默认是&#x27;\n&#x27;,结束字符会留在输入流中</span></span><br><span class="line"><span class="built_in">cin</span>.getline(stxr, length, endchar); <span class="comment">//结束字符默认是&#x27;\n&#x27;，结束字符不会留在输入流中,读入的字符是length减一，因为&#x27;\0&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>string</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="built_in">strlen</span>(str);<span class="comment">//可见字符串长度，不包括&#x27;\0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(str1, str2); <span class="comment">//不能用str1 = str2赋值，str1 要 大于 str2，//字符串排序</span></span><br><span class="line"><span class="built_in">strcat</span>(str1, str2); <span class="comment">//拼接</span></span><br><span class="line"><span class="built_in">strcmp</span>(str1, str2); <span class="comment">//比较大小，挨个比较ascii码 返回值是-1，0，1</span></span><br><span class="line"><span class="comment">//以上三个都有n族，即strncpy,strncat,strncmp，即操作前n个字符</span></span><br><span class="line"></span><br><span class="line">strlwr(str); <span class="comment">//转换为小写</span></span><br><span class="line">strupr(str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//应用</span></span><br><span class="line">len = <span class="built_in">strlen</span>(str1);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123; <span class="comment">//不推荐</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str1[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>声明可以写多次，定义只能写一次</li><li>scanf返回值是读入的个数，<code>ctrl Z</code>返回-1</li><li>cin返回值是<code>true</code>或<code>false</code></li></ol><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol><li><p>定义的时候如果不声明返回值类型，默认是<code>int</code></p></li><li><p>如果return类型和定义类型不同，则强转（以定义为准）</p></li><li><p>函数不可以嵌套定义，但可以嵌套调用。</p></li></ol><h3 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h3><ol><li>传入的类型不对时会发强转</li></ol><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><ol><li>复合语句内是局部变量</li><li>复合语句是指大括号内，不一定是循环或者函数，大括号可以随时出现，组成复合语句。</li></ol><h3 id="变量存储类型"><a href="#变量存储类型" class="headerlink" title="变量存储类型"></a>变量存储类型</h3><blockquote><p>每个变量都有两种属性，分别是<strong>数据类型</strong>和<strong>存储类型</strong>，因此标准的变量定义应该是<code>标准类型 数据类型 变量名</code></p></blockquote><ol><li>auto（自动变量）函数内部或符合语句{}内。</li><li>register（寄存器变量）</li><li>extern（外部变量）指不在此块或此块之前声明过的变量，也可以引用其它文件的变量，另外引用其它文件的函数前面的extern可以省略</li><li>static（静态（外部）变量）该变量不能由extern引用</li></ol><h3 id="数组作为参数"><a href="#数组作为参数" class="headerlink" title="数组作为参数"></a>数组作为参数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myFun</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myFun2</span><span class="params">(<span class="keyword">int</span> arr[][<span class="number">3</span>], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr1[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> arr2[][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    myFun(arr1, <span class="number">3</span>); <span class="comment">//注意，函数不会重新创建新的数组</span></span><br><span class="line">    myFun2(arr2, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带默认值的函数"><a href="#带默认值的函数" class="headerlink" title="带默认值的函数"></a>带默认值的函数</h3><ol><li>缺省形参值必须从右向左连续定义（自右向左入栈）</li><li>如果省掉了某个实参，直到最右边的实参都要省</li><li>缺省值应该在函数原型就给出</li><li>同一作用域，不可以重复定义缺省值</li><li>函数原型给出缺省值时，形参名可以省略</li><li>同一作用域内的函数原型和函数定义不能同时定义缺省值</li></ol><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fun(); <span class="comment">//本质是编译的时候将此处替换了，即变成了顺序执行，空间换取时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>仅在原型出加<code>inline</code>无效，内联函数的定义必须出现在调用之前，否则就是普通函数</strong></p><p><strong>如果函数体积较大或者函数内有循环比较耗时，则不宜用内联</strong></p><h3 id="重载函数"><a href="#重载函数" class="headerlink" title="重载函数"></a>重载函数</h3><ol><li>c语言是不支持的</li><li>仅仅是返回值不同是不行的，编译不通过</li><li>编译器决定调用哪个函数的过程称之为<strong>绑定</strong></li><li>绑定的优先级：精确-&gt;低转高-&gt;高转低</li><li>带默认值的函数等可能引起二议性</li></ol><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><ol><li>泛型化（类型的参数化）</li><li>如果模板中有普通类型，如int，则必须显示实例化</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="comment">//也可以用class</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    Swap(a, b);	<span class="comment">//自动推到调用</span></span><br><span class="line">    <span class="comment">//Swap&lt;int&gt;(a, b);//显示指定调用</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">float</span> c = <span class="number">12.3</span>;</span><br><span class="line">    <span class="keyword">float</span> d = <span class="number">23.4</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Swap(c, d); //自动推到调用</span></span><br><span class="line">    Swap&lt;<span class="keyword">float</span>&gt;(c, d); <span class="comment">//显示指定调用</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;d = &quot;</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lms1008611/article/details/81985815">参考资料《C++中的函数模板》</a></p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> * p = &amp;a;</span><br><span class="line">cou&lt;&lt;*p; <span class="comment">//解引用，找到内存中的数据</span></span><br></pre></td></tr></table></figure><p>任何类型的指针都占四个字节</p><h3 id="空指针和野指针"><a href="#空指针和野指针" class="headerlink" title="空指针和野指针"></a>空指针和野指针</h3><blockquote><p>当指针定义为0、NULL、或者不赋值，此时不能解引用，否则崩溃</p></blockquote><ol><li>空指针：指向内存编号为0的指针，一般用来初始换（0-255）不可访问，系统占用。<code>int * p = NULL</code>或<code>int * p = 0</code></li><li>野指针：指向非法空间（是一种错误），无法访问。</li></ol><h3 id="const修饰指针"><a href="#const修饰指针" class="headerlink" title="const修饰指针"></a>const修饰指针</h3><blockquote><p>指针就是一种特殊的变量，专门用来存放地址。地址可以看作一个特殊的数据类型，地址不可以复制给int变量，但可以赋值给指针变量，int的地址，只能复制给int *。地址可以解引用，所以&amp;a和p的用法是一样的。</p></blockquote><h4 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p = &amp;a;</span><br><span class="line">cou&lt;&lt;*p&lt;&lt;*&amp;a&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p %p&quot;</span>,&amp;a, p); <span class="comment">//地址的占位符应该用%p</span></span><br><span class="line">a = <span class="number">20</span>; <span class="comment">//这样是可以的</span></span><br><span class="line">*p = <span class="number">20</span>; <span class="comment">//不可以！！指针的指向可以修改，但不可以通过解引用来修改</span></span><br></pre></td></tr></table></figure><h4 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;a; <span class="comment">//指向不可以改，解引用可以改。</span></span><br></pre></td></tr></table></figure><h4 id="常量指针常量"><a href="#常量指针常量" class="headerlink" title="常量指针常量"></a>常量指针常量</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;a; <span class="comment">//都不可以改</span></span><br></pre></td></tr></table></figure><h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><blockquote><p>此处，若那指针p指向数组首地址，那么此时的<strong>数组名</strong>和<strong>指针名</strong>的本质其实都是一个<strong>指针</strong>，访问数组的元素可以通过<u>方括号</u>来访问，也可以用<u>*</u>来访问。需要注意的是p和a的区别，p是变量，但a是常量指针，a不可以进行a++等运算。另外，指针相加无意义，相减有意义。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> * p = arr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用指针遍历数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    p++; <span class="comment">//向后走四个字节，即到下个元素，p+1指向下一个元素，p-1指向上一个元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过指针引用数组元素</span></span><br><span class="line"><span class="comment">//下标法 和  指针法</span></span><br><span class="line">p[i];</span><br><span class="line">a[i];</span><br><span class="line">*(p+i);</span><br><span class="line">*(a+i);</span><br></pre></td></tr></table></figure><blockquote><p>利用指针进行排序，可以避免复杂的例如结构体、字符串的赋值，效率更高</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> arr[<span class="number">8</span>] = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> *p[<span class="number">8</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++)&#123;</span><br><span class="line">      p[i] = &amp;arr[i];</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i ++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; <span class="number">8</span>; j++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(*p[i] &gt; *p[j])&#123;</span><br><span class="line">              <span class="keyword">int</span> *temp = p[i]; </span><br><span class="line">              p[i] = p[j];</span><br><span class="line">              p[j] = temp; <span class="comment">//只交换指针的指向，而不更改</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;*p[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="指针与字符串"><a href="#指针与字符串" class="headerlink" title="指针与字符串"></a>指针与字符串</h3><blockquote><p>指向字符串常量和指向字符数组的指针有什么区别呢？</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *<span class="built_in">string</span>;</span><br><span class="line"><span class="built_in">string</span> = <span class="string">&quot;abcd&quot;</span>; <span class="comment">//string是常量区（数据段）里&quot;abcd&quot;的首地址，不可以修改*string的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *string2, ss[] = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">string2 = ss; <span class="comment">//string2是栈里&quot;abcd&quot;的首地址，可以修改*string2的值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">string</span>; <span class="comment">//即从string开始，知道&#x27;\0&#x27;结束，所以类推cout&lt;&lt;string+1即输出&quot;bcd&quot;</span></span><br></pre></td></tr></table></figure><p>要搞清楚<code>string</code>、<code>string2</code>、<code>ss</code>三者的区别：</p><ol><li>*string不可以修改，两外两个可以</li><li>ss不可以修改，两外两个可以</li><li>三者都属于指针，第一个指向常量即<strong>常量指针</strong>，第二个正常指针，第三个本身是常量即<strong>指针常量</strong></li></ol><blockquote><p>利用指针编程的实例（复制字符串）</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把字符数组a赋值给b</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[] = <span class="string">&quot;abcd&quot;</span>,b[<span class="number">10</span>],*p1,*p2;</span><br><span class="line">    p1 = a;</span><br><span class="line">    p2 = b;</span><br><span class="line">    <span class="keyword">while</span>(*p1)</span><br><span class="line">        *p2++ = *p1++;</span><br><span class="line">    *p2 = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//不要忘了最后加上&#x27;\0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针与函数（地址传递）"><a href="#指针与函数（地址传递）" class="headerlink" title="指针与函数（地址传递）"></a>指针与函数（地址传递）</h3><blockquote><p>主要注意传递指针以及返回指针</p></blockquote><p><strong>值传递是文件复制，地址传递是建立快捷方式</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> * p1, <span class="keyword">int</span> * p2)</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span>(*p1 + *p2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; add(&amp;a, &amp;b);</span><br></pre></td></tr></table></figure><h3 id="指向函数的指针"><a href="#指向函数的指针" class="headerlink" title="指向函数的指针"></a>指向函数的指针</h3><blockquote><p>用的不多</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">int</span> (*p)(<span class="keyword">int</span> <span class="keyword">int</span>);<span class="comment">//之后p和f用法相同，p可以用来传参</span></span><br></pre></td></tr></table></figure><h3 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h3><blockquote><p>与指针类似，但更安全、简单，主要用于函数的参数，不需要解引用，也不需要传参的时候传递地址</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = a; <span class="comment">//a,b地址一样，且定义的时候必须初始化，不能先定义再赋值，且以后b不能再修改</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> &amp; r)</span></span>&#123;</span><br><span class="line">    r = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line">    f(x);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;x; <span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 返回值为引用类型的引用</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">max</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;a[t]) t = i;</span><br><span class="line">        <span class="keyword">return</span> a[t]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> &amp; sum(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        s += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> &amp; m1 = max(a, <span class="number">10</span>); <span class="comment">//此处m1即为a[4]</span></span><br><span class="line">    <span class="keyword">int</span> &amp; m2 = sum(a, <span class="number">10</span>); <span class="comment">//此处m2即为s，但是s为局部变量，s释放之后，m2是随机值。</span></span><br><span class="line">    </span><br><span class="line">    max(a, <span class="number">10</span>)++; <span class="comment">//返回值是引用的话可以对返回值直接进行运算操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>常引用：不能通过常引用来修改变量的值，所以常引用可以用来引用常量，表达式等，通常用来作为只读形参。传引用更快，但又不希望被改动，所以更安全</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; b = a; <span class="comment">//a，b地址相同，唯一区别是只能通过a来修改该地址的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; x, <span class="keyword">int</span> &amp; y)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maing</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    f(<span class="number">100</span>, a); <span class="comment">// 第一个参数可以传常量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><blockquote><p>先记录一个常见的错误</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> a[n]; <span class="comment">//不合法，应该使用动态数组 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>动态数组</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *q;</span><br><span class="line">    q = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>]; <span class="comment">//new得到的是申请到的空间的地址，当系统用完时可能会失败，当失败时会返回空指针</span></span><br><span class="line">    <span class="keyword">if</span>(!q)&#123; <span class="comment">//检查new的结果</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;failed&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(q, <span class="string">&quot;abcde&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;q&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> []q;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a><strong>补充</strong></h4><blockquote><p>关于内存分配的一些问题</p></blockquote><p><img src="https://pic.imgdb.cn/item/6112334a5132923bf840aea3.jpg" alt></p><p>对于三个区域，<strong>数据段、栈、堆</strong>，全局变量存储在数据段，局部栈，动态分配堆。对于一些很大的例如<strong>大数组</strong>，不能直接在堆里创建，否则会崩溃，需要在堆里<code>new</code>，且用完之后一定要<code>delete</code>否则会不断累积，造成内存泄漏，但要注意<code>delete</code>之后不允许再操作此处内存；也可以放在数据段里，即定义全局变量。</p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="定义与使用"><a href="#定义与使用" class="headerlink" title="定义与使用"></a>定义与使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;s3 <span class="comment">//这里可以在定义的时候直接创建一个实例，不建议用</span></span><br><span class="line"><span class="comment">//创建后赋值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">student1</span>;</span> <span class="comment">//struct可以省略</span></span><br><span class="line">student1.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">student1.age = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//创建时赋值</span></span><br><span class="line">Student student1 = &#123;</span><br><span class="line">    <span class="string">&quot;张三&quot;</span>,<span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">arr</span>[3]=</span></span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">10</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">student</span> =</span> &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">10</span>&#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Student * p = student;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p-&gt;name; <span class="comment">//相当于(*p).name</span></span><br></pre></td></tr></table></figure><h3 id="结构体嵌套"><a href="#结构体嵌套" class="headerlink" title="结构体嵌套"></a>结构体嵌套</h3><p>要在之前声明</p><h3 id="结构体传参"><a href="#结构体传参" class="headerlink" title="结构体传参"></a>结构体传参</h3><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p><code>private</code>（成员函数可以访问本类其它对象私有成员）、<code>public</code>、<code>protected</code>（该类以及子类）出现的次序和顺序可以任意，默认是private</p><p>类本身并不占内存</p><h3 id="数据成员"><a href="#数据成员" class="headerlink" title="数据成员"></a>数据成员</h3><p>可以使用已定义完整的类，但当前正在定义的类没有定义完整，所以不能实例化</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grade</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> a; <span class="comment">//不占用内存空间，不可以赋初值。新标准可以赋值，但其实是通过构造函数赋值。</span></span><br><span class="line">  Grade *p;</span><br><span class="line">  Grade &amp;r;	</span><br><span class="line">  Grade b; <span class="comment">//错误</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="函数成员"><a href="#函数成员" class="headerlink" title="函数成员"></a>函数成员</h3><ol><li><p>类内定义的称为内联函数，若要在类外定义，必须在类里声明原型</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clock::SetTime</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> m, <span class="keyword">int</span> s)</span></span>&#123; <span class="comment">//::是作用域分辨符</span></span><br><span class="line">    ... <span class="comment">//访问类里变量时直接访问就可以，写法和内联一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>默认形参可以放在原型里也可以放在定义处，不可都放，一般放原型</p></li><li><p>只有一份，不会给每个实例都放个函数</p></li></ol><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ol><li>没有返回值类型，且不用void的，一般函数需要void</li><li>构造函数只能被自动调用</li><li>构造函数要放在<code>pubilc</code>里面，否则无法实例化</li><li>构造函数可以重载</li><li>只有在不定义构造函数的时候才会自动生成无参构造函数</li><li>定义有参构造函数时最好再重载一个无参构造</li></ol><h3 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Score</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Score ScoreArr[<span class="number">3</span>]; <span class="comment">//调用不带参数的构造函数</span></span><br><span class="line">    Score ScoreArr[<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;&#125;; <span class="comment">//带参构造函数，两种都行，初值表</span></span><br><span class="line">    Score ScoreArr[<span class="number">3</span>] = &#123;</span><br><span class="line">        Score(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),</span><br><span class="line">        Score(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>),</span><br><span class="line">        Score(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h4 id="常量对象"><a href="#常量对象" class="headerlink" title="常量对象"></a>常量对象</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> 类名 对象名；</span><br><span class="line">类名 <span class="keyword">const</span> 对象名；<span class="comment">//两种都可以</span></span><br></pre></td></tr></table></figure><ol><li>常对象只能调用常成员函数</li><li>常对象本身以及其内部的属性等都不可以改变</li></ol><h4 id="常成员函数"><a href="#常成员函数" class="headerlink" title="常成员函数"></a>常成员函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">int</span> <span class="title">getx</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="function"><span class="keyword">int</span> <span class="title">gety</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">A::gety</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>原型和实现都要加<code>const</code></li><li><code>const</code>可以用来重载函数</li><li>不能修改数据成员</li><li>不能调用非常成员函数</li><li>普通对象可以调用常成员函数和非常成员函数</li></ol><h4 id="常数据成员"><a href="#常数据成员" class="headerlink" title="常数据成员"></a>常数据成员</h4><blockquote><p> 定义和普通常量一样（注意：常量声明必须初始化），但是由于老标准中初始化类时不允许赋值，所以可以在构造函数里通过初始化表赋值</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> SIZE;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">3</span>; <span class="comment">//新标准才可以如此</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	A(<span class="keyword">int</span> size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A::A(<span class="keyword">int</span> size):SIZE	(size) <span class="comment">//后面为参数化表可以给一个常量或者变量赋值</span></span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><h4 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h4><blockquote><p>静态成员只保留一次拷贝</p><p>不能用构造函数初始化静态成员，必须在类外初始化</p><p>定义对象时不会为静态成员分配空间</p><p>调用时可以通过类调用也可以通过<code>obj.</code>调用，值相同</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">double</span> a;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">2</span>;<span class="comment">//静态常数据成员可以在此初始化（非静态常数据成员老标准不支持在此初始化）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> A::a = <span class="number">1.3</span>;<span class="comment">//不要忘记初始化，初始化的时候不加static</span></span><br></pre></td></tr></table></figure><h4 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h4><blockquote><p>不依赖任何对象，用来访问静态数据成员，可以通过类直接调用，也可以通过对象调用。</p><p>可以在类内声明原型，然后在类外定义，此时，类外不用加static</p><p>普通函数可以访问静态变量，但是静态函数不可以直接访问普通变量，但可以访问自己创建的或是传进来的实例的变量</p></blockquote><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>友元类</p><p>友元函数</p><p>友元成员函数</p><h3 id="对象析构与拷贝构造"><a href="#对象析构与拷贝构造" class="headerlink" title="对象析构与拷贝构造"></a>对象析构与拷贝构造</h3><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">~构造函数名();</span><br></pre></td></tr></table></figure><p>析构函数没有重载，没有参数，没有返回值</p><p>如果没有定义，系统会生成空析构函数</p><p>调用顺序和构造函数相反（出入栈）</p><h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认拷贝构造函数，可以用旧实例来初始化新实例。</span></span><br><span class="line"><span class="function">MyClass <span class="title">A2</span><span class="params">(A1)</span></span>;</span><br><span class="line">MyClass A2 = A1;</span><br></pre></td></tr></table></figure><p>在初始化，函数传参，返回值的时候会自动调用拷贝构造函数。系统默认生成拷贝构造函数。但是先声明，再赋值不会调用，而是调用<code>=</code>。注意一定是传变量的时候才会调用，如果直接传递常量MyClass</p><blockquote><p>默认拷贝构造函数比较傻，只能浅拷贝（即直接赋值），这会导致，如果你的类用到了动态内存，那么两个指针指向会相同，所以需要自己重新定义拷贝构造函数，重新开辟内存。</p><p>而当自己重新定义拷贝构造函数之后，默认的拷贝构造函数和构造函数都会消失，所以你还需要定义构造函数。</p><p>但是如果你只是重新定义构造函数，默认的拷贝构造函数依旧完好。</p></blockquote><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><blockquote><p>构造函数涉及到动态内存一定要注意</p><ul><li>拷贝构造函数</li><li>重新赋值运算符</li><li>析构函数</li></ul></blockquote><ul><li>C++ 要求’=’、’[]’、’()’、’-&gt;’运算符必须被定义为类的成员函数，把这些运算符通过全局函数进行重载时会出现编译错误；</li><li>如果有一个操作数是类类型（如 string 类），那么对于对称操作符（比如操作符“==”），最好通过全局函数的方式进行重载。</li><li>如果一个重载运算符是类的成员函数，那么只有当与它一起使用的左操作数是该类的对象时，该运算符才会被调用；而如果该运算符的左操作数确定为其他的类型，则运算符必须被重载为全局函数；</li><li>有一些运算符是不能重载的，如“sizeof”；</li><li>不能创建新的运算符；</li></ul><h4 id="重载为全局函数"><a href="#重载为全局函数" class="headerlink" title="重载为全局函数"></a>重载为全局函数</h4><ul><li>最好设置为友元函数</li></ul><h4 id="重载为成员函数"><a href="#重载为成员函数" class="headerlink" title="重载为成员函数"></a>重载为成员函数</h4><ul><li>形参少一个</li></ul><h4 id="常见的重载"><a href="#常见的重载" class="headerlink" title="常见的重载"></a>常见的重载</h4><ul><li>=可以返回*this，这样就可以连等了！</li><li>[]返回类型要加个&amp;，这样就可以通过[]修改了！</li><li>前置++，重置为一元，后置为二元（加个新参int x 会默认传0）</li><li>&gt;&gt; &lt;&lt; <strong>必须是全局</strong></li></ul><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>如果成员类没有无参构造函数，那么组合类的构造函数的时候，必须携带初始化表。**初始化表不是在调用构造函数，构造函数的调用顺序和初始化表无关，它仅仅是提供参数。顺序应该是和数据成员里声明的顺序相同。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	A(<span class="keyword">const</span> &amp;B1):B(B1)</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote><p>一些名词：继承、派生。基类、父类，派生类、子类 ，单继承，单向继承，多继承，多重继承，多层派生，多层继承</p></blockquote><p><img src="https://pic.imgdb.cn/item/612e56ce44eaada73961cd6b.jpg" alt></p><p>继承决定访问权限上限</p><p>派生类不继承<strong>构造函数、析构函数、赋值运算符</strong>，但是可以调用基类的</p><p>构造函数调用顺序：基类、成员对象、自己。</p><p>如果基类没有无参构造函数，那么派生类必须定义构造函数，通过参数表传递给基类，即便派生类本身不需要重新定义构造函数，此时重新定义的构造函数作用仅仅是传递参数。如果基类有的话则可以不定义。</p><p>对于多层派生，派生类会调用直接基类的构造函数，依次上溯。</p><p>继承方式如果不写，默认是private</p><h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A, <span class="keyword">public</span> C&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基类构造函数调用顺序按照声明的顺序，如例子中先调用A，再C</p><p>接着调用成员对象的构造函数</p><p>最后派生类</p><p>继承默认是private</p><p><strong>多继承要时刻注意可能出现二义性</strong>。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><blockquote><p>其实就是为了方便对所有的派生类进行统一管理罢了</p></blockquote><ol><li>虚函数不能是静态成员函数，也不能是友元函数，因为二者都不属于对象</li><li>多态的实现只能是指针或引用（基类指针指向派生对象，或基类引用指向派生对象）</li><li>派生类继承基类的虚函数，无论写不写<code>virtual</code>都是虚函数</li><li>派生类的重载函数会覆盖继承过来的同名虚函数</li></ol><h4 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h4><p>当派生类需要析构去delete动态内存时，如果是基类的指针，只会执行基类的析构函数，为了能够析构派生类，所以加了<code>virtual</code>。同时派生类会调用基类的析构函数。而基类不会调用派生类的析构函数。</p><h4 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h4><blockquote><p>只有原型没有实体</p></blockquote><p><code>virtual int f(int, double) = 0;</code></p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>一个类中至少有一个纯虚函数，则称之为抽象类。这种类只能作为基类，不能创建对象，但可以创建指针和引用。</p><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="built_in">string</span> s1; <span class="comment">//空串</span></span><br><span class="line"><span class="keyword">char</span> *str1 = <span class="string">&quot;hhh&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> str2[] = <span class="string">&quot;hhh&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(str1)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(str2)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">&quot;hhh&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(str1, <span class="number">3</span>)</span></span>; <span class="comment">//前几个字符</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>; <span class="comment">//拷贝构造</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1, <span class="number">2</span>, <span class="number">3</span>)</span></span>; <span class="comment">//从2，拷贝3个。</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1, <span class="number">2</span>)</span></span>; <span class="comment">//从2，拷贝到结束</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>)</span></span>; <span class="comment">///ccc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s1; <span class="comment">//开头空格不算，中间空格结束</span></span><br><span class="line">getline(<span class="built_in">cin</span>, s1, c); <span class="comment">//输入流、string、结束符（默认回车），且结束符会被丢弃。如果第一个就是结束符，那么就是空串，如果之前又输入字符，需要getchar()或者cin.get()吃掉回车。返回值是输入流</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line">s1[i]; <span class="comment">//下标，注意没有&#x27;\0&#x27;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> ch:s);<span class="comment">//范围循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch:s);<span class="comment">//类型可以自动，&amp;可以修改源字符串，否则是副本</span></span><br><span class="line"><span class="comment">//迭代器iterator reverse_itrerator const_iterator，对于常量，必须用第三个</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">string</span>::iterator it=s.begin(); it&lt;s.end(); it++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载</span></span><br><span class="line">+， =， +=， ==， ！=， &gt;, &gt;=....</span><br><span class="line">        </span><br><span class="line"><span class="comment">//方法(不写那么细致了)</span></span><br><span class="line">append();</span><br><span class="line">push_back();</span><br><span class="line">insert();</span><br><span class="line">erase();</span><br><span class="line">clear();</span><br><span class="line">replace();</span><br><span class="line">size();</span><br><span class="line">length();</span><br><span class="line">empty();</span><br><span class="line">compare();<span class="comment">//可以截取范围</span></span><br><span class="line">assign();<span class="comment">//赋值</span></span><br><span class="line">substr();<span class="comment">//子串</span></span><br><span class="line">swap();<span class="comment">//交换</span></span><br><span class="line">c_str();<span class="comment">//转换为c字符数粗</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p><img src="https://pic.imgdb.cn/item/613d583444eaada739877124.jpg" alt></p><p><img src="https://pic.imgdb.cn/item/613d58b044eaada739880e76.jpg" alt></p><h3 id="基于控制台的I-O"><a href="#基于控制台的I-O" class="headerlink" title="基于控制台的I/O"></a>基于控制台的I/O</h3><p>​ cin cout<iostream></iostream></p><h3 id="基于字符串的I-O"><a href="#基于字符串的I-O" class="headerlink" title="基于字符串的I/O"></a>基于字符串的I/O</h3><ol><li><p>istringstream：流的输入</p></li><li><p>ostringstream：流的输出</p></li><li><p>stringstream：输入输出</p></li><li><pre><code class="c++"><span class="built_in">string</span> str = <span class="string">"asdkfjasdf"</span>;
<span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(str)</span></span>;<span class="comment">//创建字符流对象</span>
ss&gt;&gt;a&gt;&gt;b&gt;&gt;s;<span class="comment">//即从ss对象输入其它变量。</span>
ss&lt;&lt;<span class="string">"234"</span>&lt;&lt;<span class="string">"2"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输入到字符串</span>
<span class="built_in">string</span> s2 = ss.str();<span class="comment">//转化为字符串</span>

<span class="comment">//可以用来做不同类型数据的转换</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> out_type, <span class="keyword">typename</span> in_type&gt;
<span class="function">out_type <span class="title">convert</span><span class="params">(<span class="keyword">const</span> in_type &amp;t)</span></span>
<span class="function"></span>&#123;
    <span class="built_in">stringstream</span> stream;
    steam&lt;&lt;t;
    out_type res;
    stream&gt;&gt;res;
    <span class="keyword">return</span> res;
&#125;
&lt;!--code￼<span class="number">42</span>--&gt;
</code></pre></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//操作样例，从文件输出</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">8</span>],score[<span class="number">6</span>];</span><br><span class="line">    ifstream txtfile;</span><br><span class="line">    txtfile.open(<span class="string">&quot;d:\\xxx.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!txtfile)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span>&lt;&lt;<span class="string">&quot;error&quot;</span>&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//cerr无缓冲输出，迅速的很呐！</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!txtfile.eof()) <span class="comment">//判断是否读完了！只不过这样会重复输出最后一行，所以在下边加个if！</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(txtfile&gt;&gt;name&gt;&gt;score)<span class="comment">//防止最后一行重复</span></span><br><span class="line">	        <span class="built_in">cout</span>&lt;&lt;name&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    txtfile.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取二进制文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CStudent s;       </span><br><span class="line">    <span class="function">ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;students.dat&quot;</span>,ios::in|ios::binary)</span></span>; <span class="comment">//二进制读方式打开</span></span><br><span class="line">    <span class="keyword">if</span>(!inFile) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(inFile.read((<span class="keyword">char</span> *)&amp;s, <span class="keyword">sizeof</span>(s))) &#123; <span class="comment">//一直读到文件结束，可以用binfile.peek()!=EOF来判断</span></span><br><span class="line">        <span class="keyword">int</span> readedBytes = inFile.gcount(); <span class="comment">//看刚才读了多少字节</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s.szName &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s.age &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    inFile.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/613d5daa44eaada7398e970d.jpg" alt></p><h2 id="分文件编写"><a href="#分文件编写" class="headerlink" title="分文件编写"></a>分文件编写</h2><ol><li>h写声明，.cpp写定义，最后新的cpp里引用.h即可</li></ol><h2 id="杂乱"><a href="#杂乱" class="headerlink" title="杂乱"></a>杂乱</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><ol><li><ctime></ctime></li><li><iostream></iostream></li></ol><h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><ol><li><p>pow是浮点计算，貌似算出来的数可能导致不相等，可以加个(int)，加（int）会导致不准确，需要自己写函数（不同编译器不一样效果）</p></li><li><p>cout输出小数不会带后面的0；</p></li><li><p>当在循环的时候要找到最好的判断方式，在最合适的地方break，不然很容易超时！</p></li><li><p>cin&gt;&gt;char1不会读入空格，scanf可以</p></li><li><p>第一个cin.getline之前要放一个getchar</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> str[<span class="number">60</span>];</span><br><span class="line">        <span class="built_in">cin</span>.getline(str, <span class="number">60</span>);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len<span class="number">-1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[j] == <span class="string">&#x27; &#x27;</span> &amp;&amp; str[j+<span class="number">1</span>] != <span class="string">&#x27; &#x27;</span>) sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;sum+<span class="number">1</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li><p>如果定义了拷贝构造函数，记得要把其它属性赋值，不然你传参的时候就错了！！！</p></li><li><p>析构貌似不用delete[];</p></li></ol><h2 id="考试复习"><a href="#考试复习" class="headerlink" title="考试复习"></a>考试复习</h2><h3 id="第一次课"><a href="#第一次课" class="headerlink" title="第一次课"></a>第一次课</h3><ol><li>‘\xCC’。\x是表示16进制，即CC是十六进制。</li><li>-=返回值是改变后的左侧的数</li><li>Size of char : 1<br>Size of int : 4<br>Size of short int : 2<br>Size of long int（long) : 8<br>Size of float : 4<br>Size of double : 8<br>Size of wchar_t : 4</li><li>1.0小数默认是double，如果是1.0f则是float</li><li><code>;</code>可以是一句话</li><li>‘0’——48，‘A’——65,’a’——97；</li><li>取余<code>%</code>必须是整型</li></ol><h3 id="第二次课"><a href="#第二次课" class="headerlink" title="第二次课"></a>第二次课</h3><ol><li><p>注意if后面不加{}的话，只能读一句。</p></li><li><pre><code class="c++"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>
<span class="function"></span>&#123;
   <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;
   <span class="keyword">if</span>(a &lt; b)
      <span class="keyword">if</span>(b &gt; c)
            <span class="built_in">cout</span>&lt;&lt;<span class="number">3</span>;
   <span class="keyword">else</span>
      <span class="built_in">cout</span>&lt;&lt;<span class="number">4</span>; <span class="comment">//最终输出4，不加括号时，else只能跟最近的if</span>
&#125;
&lt;!--code￼<span class="number">45</span>--&gt;</code></pre></li><li><p>函数原型可以只声明变量类型，而不声明变量名称，且不需要<code>&#123;&#125;</code>；</p></li><li><p>函数都要通过main来调用，main是入口，所以函数不能单独运行，但是可以单独编译</p></li></ol><h3 id="第八次课"><a href="#第八次课" class="headerlink" title="第八次课"></a>第八次课</h3><ol><li>对于<code>double a[3][5]</code>，<code>a[1][5]</code>是不对的！</li><li><code>char a[3] = &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;</code>不可以用strlen()，因为没有结束符’\0’。</li><li>对于c_string的字符数组，注意最后的结束符，另外<code>\\</code>是一个字符。</li></ol><h3 id="第九次课"><a href="#第九次课" class="headerlink" title="第九次课"></a>第九次课</h3><ol><li>不可以用1，’a’这样的常量给指针赋值</li><li><code>int a[] = &#123;1,2,3&#125;</code>a是不可以变的！但是如果是形参，是可以变的！</li></ol><h3 id="第十一次课"><a href="#第十一次课" class="headerlink" title="第十一次课"></a>第十一次课</h3><ol><li>函数模板显示实例化与隐式实例化的条件，如果有普通类型，如int，则必须显示</li></ol><h3 id="第十二次课"><a href="#第十二次课" class="headerlink" title="第十二次课"></a>第十二次课</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ST</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">long</span> a;</span><br><span class="line">   <span class="keyword">int</span> b;</span><br><span class="line">   <span class="keyword">char</span> c[<span class="number">2</span>];</span><br><span class="line">&#125;NEW; <span class="comment">// 给结构体起了别名，如果没有typedef的话，NEW在此处表示一个结构体</span></span><br><span class="line"></span><br><span class="line">ST st[] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;b&#x27;</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(&amp;st[<span class="number">0</span>])-&gt;a; <span class="comment">//必须加括号，不然编译出错。</span></span><br></pre></td></tr></table></figure><h3 id="第十三次课"><a href="#第十三次课" class="headerlink" title="第十三次课"></a>第十三次课</h3><ol><li><p>常成员函数不可以修改属性值，但可以访问。常成员函数不可以调用非常成员函数。</p></li><li><p>常成员函数可以访问类中的所有数据成员，但不能修改。注意常数据成员要被初始化，（可以在构造函数初始化0</p></li><li><p>静态函数可以访问静态变量，但不能访问其它变量。普通函数可以访问静态变量。</p></li><li><p>注意静态数据成员的初始化</p></li><li><p>普通成员函数不能<code>:x(a),y(b)</code>；</p></li><li><p>常对象只能调用常成员函数</p></li><li><p>拷贝构造函数的参数<code>const point &amp;p</code></p></li><li><p>友元函数可以把原型和定义都写在类里，但是即便写在类里，也不是成员函数。<code>friend</code>只能用在类里。</p></li><li><p>当涉及到友元成员函数的时候，因为会涉及到相互依赖的问题，所以只写函数原型，函数定义要放在后面。</p></li><li><p><code>%</code>，必须是<code>int</code></p></li><li><p><code>switch</code>注意后面是否有break！</p></li></ol><h3 id="第十四次课"><a href="#第十四次课" class="headerlink" title="第十四次课"></a>第十四次课</h3><ol><li>是double后面要有个小数点么</li><li>函数默认返回值是int</li><li>赋值表达式<code>t=1</code>的值是t</li></ol></div><div class="reward-container"><div></div> <button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'> b(￣▽￣)d</button><div id="qr" style="display:none"><div style="display:inline-block"> <img src="/images/wechat.png" alt="Asea 微信支付"><p>微信支付</p></div><div style="display:inline-block"> <img src="/images/alipay.png" alt="Asea 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> Asea</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://asea.fun/post/258a2097.html" title="c++学习笔记">https://asea.fun/post/258a2097.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><p>\(@^0^@)/</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="https://www.zhihu.com/people/michael-48-84-31"><span class="icon"><i class="fab fa-zhihu"></i></span> <span class="label">知乎</span></a></div><div class="social-item"><a target="_blank" class="social-link" href="https://weibo.com/5568238770/profile?rightmod=1&wvr=6&mod=personinfo"><span class="icon"><i class="fab fa-weibo"></i></span> <span class="label">微博</span></a></div><div class="social-item"><a target="_blank" class="social-link" href="https://blog.asea.fun"><span class="icon"><i class="fa fa-user"></i></span> <span class="label">另一个博客</span></a></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/c/" rel="tag"><i class="fa fa-tag"></i> c++</a></div><div class="post-nav"><div class="post-nav-item"><a href="/post/eb0811b7.html" rel="prev" title="初探Java"><i class="fa fa-chevron-left"></i> 初探Java</a></div><div class="post-nav-item"> <a href="/post/5d8c0cb2.html" rel="next" title="留言本">留言本<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E5%A4%A7%E4%BB%B6"><span class="nav-number">1.</span> <span class="nav-text">四大件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">3.</span> <span class="nav-text">运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">控制结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">5.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">5.1.</span> <span class="nav-text">一维数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">5.2.</span> <span class="nav-text">二维数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">5.3.</span> <span class="nav-text">字符串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">6.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F"><span class="nav-number">6.1.</span> <span class="nav-text">注意</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">6.2.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E5%8F%82"><span class="nav-number">6.3.</span> <span class="nav-text">传参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">6.4.</span> <span class="nav-text">变量作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.5.</span> <span class="nav-text">变量存储类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="nav-number">6.6.</span> <span class="nav-text">数组作为参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">6.7.</span> <span class="nav-text">带默认值的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-number">6.8.</span> <span class="nav-text">内联函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0"><span class="nav-number">6.9.</span> <span class="nav-text">重载函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">6.10.</span> <span class="nav-text">函数模板</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-number">7.</span> <span class="nav-text">指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="nav-number">7.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88%E5%92%8C%E9%87%8E%E6%8C%87%E9%92%88"><span class="nav-number">7.2.</span> <span class="nav-text">空指针和野指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88"><span class="nav-number">7.3.</span> <span class="nav-text">const修饰指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88"><span class="nav-number">7.3.1.</span> <span class="nav-text">常量指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F"><span class="nav-number">7.3.2.</span> <span class="nav-text">指针常量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F"><span class="nav-number">7.3.3.</span> <span class="nav-text">常量指针常量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84"><span class="nav-number">7.4.</span> <span class="nav-text">指针和数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">7.5.</span> <span class="nav-text">指针与字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E5%87%BD%E6%95%B0%EF%BC%88%E5%9C%B0%E5%9D%80%E4%BC%A0%E9%80%92%EF%BC%89"><span class="nav-number">7.6.</span> <span class="nav-text">指针与函数（地址传递）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-number">7.7.</span> <span class="nav-text">指向函数的指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="nav-number">7.8.</span> <span class="nav-text">引用传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="nav-number">7.9.</span> <span class="nav-text">动态内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">7.9.1.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A5%E5%85%85"><span class="nav-number">7.9.2.</span> <span class="nav-text">补充</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">8.</span> <span class="nav-text">结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="nav-number">8.1.</span> <span class="nav-text">定义与使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84"><span class="nav-number">8.2.</span> <span class="nav-text">结构体数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88"><span class="nav-number">8.3.</span> <span class="nav-text">结构体指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97"><span class="nav-number">8.4.</span> <span class="nav-text">结构体嵌套</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%BC%A0%E5%8F%82"><span class="nav-number">8.5.</span> <span class="nav-text">结构体传参</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="nav-number">9.</span> <span class="nav-text">面向对象编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">9.1.</span> <span class="nav-text">类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="nav-number">9.2.</span> <span class="nav-text">数据成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98"><span class="nav-number">9.3.</span> <span class="nav-text">函数成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">9.4.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="nav-number">9.5.</span> <span class="nav-text">对象数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-number">9.6.</span> <span class="nav-text">常量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1"><span class="nav-number">9.6.1.</span> <span class="nav-text">常量对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">9.6.2.</span> <span class="nav-text">常成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="nav-number">9.6.3.</span> <span class="nav-text">常数据成员</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-number">9.7.</span> <span class="nav-text">静态成员</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="nav-number">9.7.1.</span> <span class="nav-text">静态数据成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">9.7.2.</span> <span class="nav-text">静态成员函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8B%E5%85%83"><span class="nav-number">9.8.</span> <span class="nav-text">友元</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%9E%90%E6%9E%84%E4%B8%8E%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0"><span class="nav-number">9.9.</span> <span class="nav-text">对象析构与拷贝构造</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">9.9.1.</span> <span class="nav-text">析构函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">9.9.2.</span> <span class="nav-text">拷贝构造函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">9.10.</span> <span class="nav-text">运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%BA%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0"><span class="nav-number">9.10.1.</span> <span class="nav-text">重载为全局函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%BA%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">9.10.2.</span> <span class="nav-text">重载为成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-number">9.10.3.</span> <span class="nav-text">常见的重载</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88"><span class="nav-number">9.11.</span> <span class="nav-text">组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">9.12.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="nav-number">9.12.1.</span> <span class="nav-text">多继承</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">9.13.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">9.13.1.</span> <span class="nav-text">虚析构函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">9.13.2.</span> <span class="nav-text">纯虚函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">9.13.3.</span> <span class="nav-text">抽象类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STL"><span class="nav-number">10.</span> <span class="nav-text">STL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#string"><span class="nav-number">10.1.</span> <span class="nav-text">string</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-number">11.</span> <span class="nav-text">输入输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%9A%84I-O"><span class="nav-number">11.1.</span> <span class="nav-text">基于控制台的I&#x2F;O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84I-O"><span class="nav-number">11.2.</span> <span class="nav-text">基于字符串的I&#x2F;O</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99"><span class="nav-number">12.</span> <span class="nav-text">分文件编写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%82%E4%B9%B1"><span class="nav-number">13.</span> <span class="nav-text">杂乱</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-number">13.1.</span> <span class="nav-text">头文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B8%A9%E5%9D%91"><span class="nav-number">13.2.</span> <span class="nav-text">踩坑</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0"><span class="nav-number">14.</span> <span class="nav-text">考试复习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AF%BE"><span class="nav-number">14.1.</span> <span class="nav-text">第一次课</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%AF%BE"><span class="nav-number">14.2.</span> <span class="nav-text">第二次课</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E6%AC%A1%E8%AF%BE"><span class="nav-number">14.3.</span> <span class="nav-text">第八次课</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B9%9D%E6%AC%A1%E8%AF%BE"><span class="nav-number">14.4.</span> <span class="nav-text">第九次课</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E6%AC%A1%E8%AF%BE"><span class="nav-number">14.5.</span> <span class="nav-text">第十一次课</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E6%AC%A1%E8%AF%BE"><span class="nav-number">14.6.</span> <span class="nav-text">第十二次课</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E6%AC%A1%E8%AF%BE"><span class="nav-number">14.7.</span> <span class="nav-text">第十三次课</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E6%AC%A1%E8%AF%BE"><span class="nav-number">14.8.</span> <span class="nav-text">第十四次课</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Asea" src="/images/avatar1.png"><p class="site-author-name" itemprop="name">Asea</p><div class="site-description" itemprop="description">我以為我可以獨自過一生 我還是被打動了</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">58</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">39</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/AAAAsea" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AAAAsea" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="https://space.bilibili.com/470490357" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;470490357" rel="noopener" target="_blank"><i class="fa fa-tv fa-fw"></i> Bilibili</a></span><span class="links-of-author-item"><a href="http://wpa.qq.com/msgrd?v=3&amp;uin=569389750&amp;site=qq&amp;menu=yes" title="QQ → http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;569389750&amp;site&#x3D;qq&amp;menu&#x3D;yes" rel="noopener" target="_blank"><i class="fab fa-qq fa-fw"></i> QQ</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/michael-48-84-31" title="ZhiHu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;michael-48-84-31" rel="noopener" target="_blank"><i class="fab fa-black-tie fa-fw"></i> ZhiHu</a></span></div><div class="cc-license motion-element" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://asea.fun/" title="https:&#x2F;&#x2F;asea.fun">我的主页</a></li><li class="links-of-blogroll-item"> <a href="https://blog.asea.fun/" title="https:&#x2F;&#x2F;blog.asea.fun" rel="noopener" target="_blank">Butterfly主题博客</a></li><li class="links-of-blogroll-item"> <a href="https://alicee.run/" title="https:&#x2F;&#x2F;alicee.run" rel="noopener" target="_blank">Alice Wonderland博客</a></li><li class="links-of-blogroll-item"> <a href="/fun/apesk/" title="&#x2F;fun&#x2F;apesk&#x2F;">APESK-荣格理论测试</a></li><li class="links-of-blogroll-item"> <a href="https://game01.asea.fun/" title="https:&#x2F;&#x2F;game01.asea.fun" rel="noopener" target="_blank">生长方块</a></li><li class="links-of-blogroll-item"> <a href="https://game02.asea.fun/" title="https:&#x2F;&#x2F;game02.asea.fun" rel="noopener" target="_blank">奔跑吧小球</a></li><li class="links-of-blogroll-item"> <a href="https://game03.asea.fun/" title="https:&#x2F;&#x2F;game03.asea.fun" rel="noopener" target="_blank">见缝插针</a></li><li class="links-of-blogroll-item"> <a href="https://hole.asea.fun/" title="https:&#x2F;&#x2F;hole.asea.fun" rel="noopener" target="_blank">合成黑洞</a></li><li class="links-of-blogroll-item"> <a href="/fun/mi/" title="&#x2F;fun&#x2F;mi&#x2F;">随机密码</a></li><li class="links-of-blogroll-item"> <a href="/fun/chi/" title="&#x2F;fun&#x2F;chi&#x2F;">吃什么</a></li><li class="links-of-blogroll-item"> <a href="/fun/du/" title="&#x2F;fun&#x2F;du&#x2F;">毒鸡汤</a></li><li class="links-of-blogroll-item"> <a href="/fun/hua/" title="&#x2F;fun&#x2F;hua&#x2F;">画板</a></li></ul></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2019 – <span itemprop="copyrightYear">2021</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">©2021 by Asea</span></div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("12/14/2019 22:08:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已偷偷运行 "+dnum+" 天",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script><div class="theme-info"><div class="powered-by"></div> <span class="post-count">全站共78.1k字</span></div><div class="busuanzi-count"><script async src="/lib/busuanzi.pure.min.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style=""><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style=""><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script defer="defer" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script><script defer="defer" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three-waves.min.js"></script><script src="/js/local-search.js"></script><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Nh54YkjOBcUzuCYRfY0LerTh-MdYXbMMI',
      appKey     : 'XeawwdLURQJN3MnHMpcY9sm3',
      placeholder: "在这里评论",
      avatar     : 'retro',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
    
  }, window.Valine);
});
</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"right",width:170,height:340},mobile:{show:!1},log:!1})</script></body></html>